A のすべての長さ
L の連続部分列の総和が
M の倍数であることは、以下の条件をともに満たすことと同値です。

- A1 + A2 + … + AL が M の倍数
- 1 ≤ i ≤ N−L なる任意の i について Ai − Ai+L が M の倍数

このことから、
A1, A2, …, AL への操作回数がわかっているとき、
i = L+1, L+2, …, N について Ai への操作回数は
Ai−L と Ai を M で割った余りが等しくなるような最小の回数であることがわかります。

---

fi,j を Ai, AL+i, A2L+i, … を M で割った余りがすべて j になるために必要な操作回数の最小値とします。
これは愚直に O(NM) 時間で計算が可能です。

fi,j の値を利用して dp による計算を行います。

---

dpi,j を A1, A2, …, Ai までの操作回数を確定させて、
A1 + A2 + … + Ai を M で割った余りが j であるときの操作回数の最小値として定めます。

ただし、ここでの操作回数の最小値とは、
A1, A2, …, Ai に対するものだけではなく、
添え字を L で割った余りが 1,2,…,i （を L で割った余り）と等しい要素全体への操作回数について考えます。

上の議論から、Ai に対する操作回数を決めたとき、
AL+i, A2L+i, … に対する操作回数も決まるので、このような計算が行えます。

---

具体的な dp の遷移について解説します。

Ai を M で割った余りを k にさせると決めたとき、
Ai, AL+i, A2L+i, … に対する操作回数の最小値は（その定義から）fi,k です。

したがって、
X
dpi,((j+k) mod M) ← min(dpi,((j+k) mod M), dpi−1,j + fi,k)

として dp の計算を行うことができます。

最終的な答えは **dpL,0** です。

---

計算量:
- dp の計算は全体として O(LM^2) 時間
- 適切な実装のもと十分高速です。

**Bonus : O(NM) 時間で解けます。**
